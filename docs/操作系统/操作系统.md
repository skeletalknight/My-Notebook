# 操作系统

!!! info "课程简介"

     所属大学：南京大学
     
     授课老师：蒋炎岩
     
     先修要求：体系结构 + 扎实的 C 语言功底
     
     编程语言：C 语言
     
     课程难度：🌟🌟🌟🌟
     
     预计学时：150 小时

重要的参考教材：[Operating Systems: Three Easy Pieces](https://pages.cs.wisc.edu/~remzi/OSTEP/)





!!! note "核心一，程序眼中的操作系统：对象 + API"

    从**应用程序**的视角看，操作系统定义了一系列的对象 (进程/线程、地址空间、文件、设备……) 和操纵它们的 API (系统调用)

!!! note "核心二，硬件眼中的操作系统”：程序 (状态机)"

    从**硬件**的视角看，操作系统是一个拥有访问全部硬件功能的程序。操作系统加载完第一个程序后，从此作为 “中断处理程序” 在后台管理整个计算机系统。实际上，运算和访存指令、I/O、中断/异常和虚存就是我们实现操作系统所需的全部。



## 什么是操作系统

操作系统萌生于对硬件的调用，对软件的支持。本课程讨论狭义的操作系统，即

> 对单一计算机硬件系统作出抽象、支撑程序执行的软件系统

操作系统随着计算机使用需求的发展而发展，我们也可以窥见其功能的作用

| 年代 | 需求/发展            | 功能                                         |
| ---- | -------------------- | -------------------------------------------- |
| 50s  | 多用户排队共享计算机 | 提供库函数和调度器，实现自动切换程序（换卡） |
| 60s  | 处理器、内存进步     | 同时将多个程序载入内存——出现进程及切换概念   |
| 70s+ | UNIX诞生并走向完善   | 分时系统走向成熟                             |

操作系统的本质仍是程序，它为程序服务，提供对象和API



## 最小的应用程序

以下是一个初学者很熟悉的，最简单的C语言代码

```c
#include <stdio.h>
int main(){
    printf("Hello, World");
    return 0;
}
```

然而，在实际执行上，这个代码一点也不小：

在编译器处理`#include <stdio.h>`头文件时，会首先插入约700多行的定义代码，随后相应的汇编码也会变得复杂——如果我们选择静态链接（将库的执行程序也插入进去），那么最后的汇编码将非常巨大，近149491行，1MB的大小。

事实上，我们可以用汇编码和系统调用，写一个更简单的`Hello, world`的代码

```assembly
.section .text
.global _start

_start:
    # write系统调用
    mov $1, %rax        # 系统调用号1（sys_write）
    mov $1, %rdi        # 文件描述符1（标准输出）
    lea msg(%rip), %rsi # 字符串地址（RIP相对寻址）
    mov $15, %rdx      # 字符串长度
    syscall			#启动系统调用

    # exit系统调用
    mov $60, %rax       # 系统调用号60（sys_exit）
    xor %rdi, %rdi      # 退出状态码0
    syscall
	
.section .rodata
msg:
    .ascii "Hello World" # 字符串数据
len = . - msg           # 计算字符串长度
```

??? note "系统调用的汇编码"

	系统调用时，我们将需要调用的功能放置于%rax寄存器，后续的参数依次存放于%rdi,%rsi,%rdx,%r10,%r8,%r9之中，然后其返回值会录入到%rax。对于汇编码语句的切换，我们记录语句位置的指针在%rip
	
	在完成以上参数的传递后，使用syscall进行系统调用

直接使用`ld`进行编译，使用`objdump`可以看到他的汇编码保持着简洁，而使用`strace`去追踪可执行文件，我们可以看到三次系统调用——启动，写入（标准输出），退出

## 什么是程序

我们说，所有程序都是和以上的，最简单的代码一样的状态机——执行自己的状态变化，并调用系统函数，即——具有**状态，初始状态，迁移**

C程序的状态机模型：

- 状态 = 栈帧及其PC(Program counter)的列表 + 全局变量
- 初始状态 = main(argc, atgv) + 全局变量初始化
- 迁移 = 执行顶部栈帧的PC的语句 = PC++
	- 函数调用/返回 = push/pop 栈帧

二进制程序的状态机

- 状态 = 内存 M + 寄存器 R
- 初始状态 = 由 ABI 规定 (例如有一个合法的 %rsp)
- 迁移 = 根据PC 执行一条指令

特别的，作为状态机（包括操作系统本身），需要调用外部系统（syscall）才能实现自身的开关

那么高级语言的代码是如何变为二进制文件的，又是如何实现系统调用的？

以C代码为例，我们可以将它变为每条语句最多一次运算（包括函数调用）的"SimpleC"

在"SimpleC"下，我们几乎可以实现C代码到指令集的直译关系，进而实现它的编译。

从这个角度讲**编译器就是状态机的转换**。



??? note "编译优化"
	编译优化，是在不改变程序的语义 (即程序的行为和输出结果) 的前提下，提高程序的执行效率和/或减少程序的资源消耗。编译优化最常见的三个方法如下：

	- 函数内联：将函数调用替换为函数体本身的内容
	
	- 常量传播：在编译时计算常量表达式的值并替换
	
	- 死代码消除：删除永远不会被执行到的代码
	
	相对保守的看法是，优化的底线是生成的所有syscall一致



## 固件：接管系统的第一个程序

固件(Firmware) 是一种嵌入在硬件设备中的软件，用于控制硬件的基本功能——它提供了硬件的控制、交互、配置接口

而在主板上的固件被称为BIOS。计算器启动时，会自动从BIOS读取初始程序，来启动整个系统，基础流程如下：

- 执行 POST（Power-On Self Test，上电自检）以检查硬件是否正常。

- 初始化硬件设备（如 CPU、内存、硬盘等）。

- 提供硬件与操作系统之间的接口（例如通过中断调用）。

- 加载操作系统的引导程序（ MBR，存储在硬盘或 USB 设备）。

!!! info "UEFI"

	UEFI 是 BIOS 的现代版本，提供了更快的启动速度、更大的硬盘支持（如 GPT 分区表）和更安全的引导过程（如 Secure Boot），并且对多操作系统的支持更好	
	
	UEFI 的启动过程与 BIOS 不同，使用的是磁盘的EFI分区。EFI分区通常默认是磁盘第一个独立分区，使用 FAT32 文件系统，并包含引导加载程序和驱动程序等。


固件一般是只读的——但是为了更新，可以在特定条件下打开写保护（如BIOS需要写入特定序列）



## 操作系统模型

和其他程序一样，操作系统也可以被视为状态机：

- 状态 = 多个应用程序的状态
- 初始状态 = 仅有一个主进程，且主进程为初始状态
- 迁移 = 选择一个程序执行一步

在这里我们可以把操作系统的重要调用抽象如下：

| 模块   | 系统调用     | 行为                            |
| ------ | ------------ | ------------------------------- |
| 基础   | choose(xs)   | 返回一个 xs 中的随机的选择      |
| 基础   | write(s)     | 向调试终端输出字符串 s          |
| 并发   | spawn(fn)    | 创建从 fn 开始执行的线程        |
| 并发   | sched()      | 切换到随机的线程/进程执行       |
| 虚拟化 | fork()       | 创建当前状态机的完整复制        |
| 持久化 | bread(k)     | 读取虚拟设磁盘块 k*k* 的数据    |
| 持久化 | bwrite(k, v) | 向虚拟磁盘块 k*k* 写入数据 v*v* |
| 持久化 | sync()       | 将所有向虚拟磁盘的数据写入落盘  |
| 持久化 | crash()      | 模拟系统崩溃                    |

这就是最简易但完整的操作系统——后续的课程就是学习其中的细节

