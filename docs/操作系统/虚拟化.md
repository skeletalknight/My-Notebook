## 虚拟内存

**虚拟内存（Virtual Memory）**是操作系统提供的一种抽象机制，它将物理内存和磁盘空间结合，为<u>每个进程</u>提供<u>连续的、隔离的地址空间</u>。

在虚拟内存下，应用程序无需感知数据实际存储位置，由操作系统加载程序运行需要的部分到物理内存

### 分页系统

#### 页映射

操作系统一般将虚拟/物理内存划分为固定大小的页（通常4KB，但可指定2MB、1GB大页），作为操作的基础单元。页内物理地址连续，页间的物理地址可能不联系，但是通过排列在页表当中，在进程眼中是连续的。

页有着**虚拟页→物理页帧**的映射，这种映射记录在页表（Page Table）当中。页表记录着**物理页帧号**，以及**状态位**（如存在位（Present/Absent）、修改位（Dirty）、读写权限等），一个完整的页表项为4/8字节

以32位系统，简单页表为例，假设虚拟地址`0x12345678`，有`0x12345`为页表项地址（相对于页表基址，每个进程独有），查询页表获得物理页帧，如`0xABCDE678`即真实物理地址。

#### 多级页表

接上例，对于每个进程，都需要有一个能完整映射全体物理地址的页表——这是一个连续的数组，在32位（4GB内存）下，一般需要4MB的页表存储空间（无论进程大小），这会大大提高内存占用。

实际上，大部分的进程并不会使用所有的页表内容，我们只需要存储那些用到的页表的映射就好了，于是我们引入了多级页表。

一个进程的内存地址空间，通常是“两头实，中间空”——栈的内存地址从顶部往下，不断分配占用的栈的空间。而堆的空间，内存地址则是从底部往上，是不断分配占用的。因此，虚拟内存占用的地址空间，通常是**两端连续**的空间。（这也是为什么简单页表都需要4MB）

我们使用多级页表来实现映射。具体而言，虚拟内存将表示为`多个页表索引+偏移`的形式，查找时会从高级页表查询至低级页表，直至获取真实的物理地址。当进程需要完全占用时，多级页表仍需要较高的存储空间；但是当不需要完全占用时，我们可以不创建中间的高级页表对应的低级页表（最高级页表仍需存在），进而降低空间占用。

多级页表虽然节约了我们的存储空间，却带来了**时间上的开销**，对于n级页表，每次访问需要进行n次内存访问，造成时间开销。

### TLB

由于将虚拟内存转为物理内存，会造成访问开销，我们在CPU cache当中（如L1，L2）存储经常使用的条目，页表查询时优先从TLB中读取，如果未命中再进行页表的查询。

TLB能大大减少虚拟内存转换的开销，特别是多级页表。在程序运行中，典型的页表命中率>95%

若TLB空间满了，通过**LRU**策略替换最久未使用的条目。为了减少TLB存储压力，可以使用大页、PCID（跨进程）、预取等优化技术。

为了防止TLB访问不存在的页，物理页被释放或替换后，会进行广播，保证TLB同步更新，同时页表项的内容也会更新

#### 页的操作

修改页的操作会如下进行：

1. 进程访问虚拟地址时，CPU的MMU（内存管理单元）通过页表查找对应的物理页。
2. 若页表项标记为“存在”（Present=1），直接修改物理页内容。
3. 若页表项标记为“不存在”（Present=0），触发**缺页异常（Page Fault）**，操作系统需从磁盘（如交换空间或文件）加载该页到物理内存，更新页表后，进程继续执行修改。
4. 修改页后，系统会自动设置**Dirty Bit**，内核线程会定期更新页到磁盘。

当物理内存不足时，会选择被替换的页面，将其存储到磁盘空间中。常见的置换算法有LRU，Clock等。

特别的若页被标记为**COW**（写时复制 Copy-on-Write，如父子进程共享内存），首次修改时会触发复制新页，避免直接修改原页。



### 内存的系统调用

#### 基本指令

在 Linux 系统中，`mmap`、`munmap` 和 `mprotect` 是三个关键的内存相关的系统调用。它们分别对应内存映射、内存释放、权限修改。

```c
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
//申请虚拟地址空间，成功返回映射区域的起始地址，失败返回 MAP_FAILED
int munmap(void *addr, size_t length);
//释放由 mmap 映射的内存区域，或撤销文件映射。
int mprotect(void *addr, size_t length, int prot);
//动态调整已映射内存区域的访问权限（如将只读内存改为可写）。
```

其中内存保护权限**`prot`**，通过位掩码指定：

- `PROT_READ`：可读
- `PROT_WRITE`：可写
- `PROT_EXEC`：可执行
- `PROT_NONE`：不可访问（用于隔离内存）

#### 常用标志

|      **标志**       |                           **作用**                           |                         **适用场景**                         |
| :-----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  **`MAP_SHARED`**   | 共享映射，修改会同步到文件（若映射文件），且对其他进程可见。 |          - 进程间通信（IPC）<br /> - 文件持久化修改          |
|  **`MAP_PRIVATE`**  |  私有映射，修改采用写时复制（COW），不影响文件或其他进程。   | - 动态内存分配（类似`malloc`）<br /> - 只读文件映射（避免修改原文件） |
| **`MAP_ANONYMOUS`** |           匿名映射，不关联文件，直接分配物理内存。           | - 大块内存分配（替代`malloc`） <br />- 进程间共享匿名内存（需配合`MAP_SHARED`） |
|   **`MAP_FIXED`**   |        强制使用指定地址（`addr`参数），若冲突则失败。        |              - 特殊内存布局需求（如嵌入式系统）              |
| **`MAP_NORESERVE`** |          不预留交换空间（swap），适合稀疏内存分配。          |           - 分配超大但稀疏使用的内存（如稀疏矩阵）           |
| **`MAP_POPULATE`**  |            预加载页到物理内存，减少后续缺页中断。            |                    - 实时系统或低延迟场景                    |
|  **`MAP_LOCKED`**   |             锁定内存，禁止被交换到磁盘（swap）。             | - 安全敏感数据（防交换泄露）<br /> - 实时应用（避免换页延迟） |
|  **`MAP_HUGETLB`**  |       使用大页（Huge Pages），减少TLB缺失，提升性能。        |         - 高性能计算（HPC）、数据库等大内存带宽应用          |

#### 文件映射

通过传入`fd`可以将内存与文件之间建立联系。`fd`一般从3开始，跳过`stdin, stdout, sdterr`。匿名内存一般设`fd`为`-1`

系统会定期扫描页缓存，同步变化的内容到磁盘。同时，也可以调用函数强制同步。

```c
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd = open("test.txt", O_RDWR);  // 打开文件
    char *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    
    ptr[0] = 'A';  // 修改映射的内存（实际修改页缓存）
    msync(ptr, 4096, MS_SYNC);  // 强制同步到磁盘
    munmap(ptr, 4096);
    close(fd);
    return 0;
}
```

###  入侵虚拟内存

我们可以通过其他进程，入侵进程的虚拟内存。

一个非常典型的案例，就是游戏的作弊器——通过观察游戏分配内存，在游戏内事件发生后的变化，可以找到关键的内存位置。对它们进行修改就可以实现游戏作弊（生命值、金钱等）

而我们也可以基于此实现更复杂的操作。如劫持时间相关的系统函数，实现变速（变速齿轮）、用一段代码勾住函数执行，实现自动操作（开镜自瞄）等

当然，除了游戏以外，入侵虚拟内存还有广泛的应用：例如使用gdb进行调试，或者对系统内核进行热更新。