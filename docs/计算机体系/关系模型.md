# 关系模型

## 关系模型构成

关系模型是基于<u>数学中</u>的关系(relation)的概念

 关系是由行和列组成的表(Table)

行(Row)，记录了单个对象，即关系的元组（tuple）。元祖的个数是关系的基数。

对应的列(col)记录了其属性（attribute）。每个属性具有取值集合，即域（domain）。

<u>关系中不允许出现重复的元组</u>，为了辨识元组，需要使用**码**：

- 超码：可以唯一标识每个元组的一个或多个属性
- 候选码：本身为超码，任何真子集都不再是超码
- 主码：从候选码中被选来唯一标识关系中各元组
- 外码：当一个关系中的某个属性集合，与另一个关系的候选码匹
	配，即可为外码

需要注意，关系的属性、元组无顺序

## 关系代数

关系代数是关系数据模型的正式理论语言，关系在关系代数下是**封闭**的

关系代数定义的操作可以从一个或多个关系得到另一个关系，而不改变原关系

注意，一个关系内的属性、元组不会重复

| 操作名   | 符号表达                 | 效果                                                         |
| -------- | ------------------------ | ------------------------------------------------------------ |
| 选择     | $\sigma_{predicate}(R) $ | 对关系R，取满足条件的元组为新关系                            |
| 投影     | $\Pi_{coln...}(R)$       | 对关系R，得到由R的一个<u>垂直子集</u>构成的新关系（去掉重复元组） |
| 集合并   | $R \cup S$               | 两个<u>并相容</u>的关系R和S并，定义一个包含R和S中所有<u>不同元组</u>的新关系 |
| 集合差   | $R - S$                  | 两个<u>并相容</u>的关系的R和S差，定义了由所有属于R但不属于S的元组构成的新关系 |
| 集合交   | $R \cap S$               | 两个<u>并相容</u>的关系R和S交，定义了由既属于R又属于S的元组组成的新关系 |
| 笛卡尔积 | $R \times S$             | 关系R和S并联的新关系，使用关系名作为属性名的前缀，以确保属性唯一性 |
| 连接关系 | $R\Join_{F}S$            | 对执行了笛卡尔积的新关系进行选择运算，即$\sigma_F(R \times S)$ |
| 除法运算 | $R \div S$               | 假设关系R定义在属性集合A上，关系S定义在属性集合B上，并且B ⊊ A ，定义 C=A-B<br/>除法运算定义了属性集合为C的一个关系，其元组与S中**每个元组的组合**都能在R中找到匹配元组 |

（**并相容**：指两个关系拥有相同数量属性，且对应属性的域相同，但属性名可不同。一般可以使用投影使得两个关系并相容）

## 规范性理论

具体情况下，对关系模型的具体设计，一般采用**规范化理论**

### 定义

对于一个关系**R**，我们着重研究的是其属性名集合**U**下，属性间数据的依赖关系集合**F**

**数据依赖**，即值之间的相关性，关系中蕴含属性与属性之间的约束关系。

数据依赖分为两类：

- 函数依赖（FD）：

	对于R上的属性集X，Y，存在映射$X{\longrightarrow}Y $，则称为“Y函数依赖于X”（一般取Y不含于X，即非平凡的函数依赖）

	若X的任一真子集X'，都无法函数确定Y，则称为完全函数依赖，记为$X\overset{F}{\longrightarrow}Y $；否则称为不完全函数依赖，记为$X\overset{P}{\longrightarrow}Y $

	如果有$X{\longrightarrow}Y , Y{\longrightarrow}Z$，<u>且X不函数依赖于Y</u>，则称Z对X存在传递函数依赖

	函数依赖需要X，Y的所有实例均满足；设计时可以强加约束以满足函数依赖

- 多值依赖（MVD）：

	对于X，Y和它们的补集Z（Z=U-X-Y），若任一一对（x, z）值，有一组Y的值仅取决于x，则存在多值依赖

	此时称Y多值依赖于X，记作$X{\longrightarrow}{\longrightarrow}Y $（一般取Z ≠ ∅，即非平凡的多值依赖）

对于一个不好的关系模型，常出现的问题：

- **数据冗余**：某属性依赖于其他属性，反复出现
- **更新异常**：更新所有某重复数据时容易出错
- **插入/删除异常**：某属性与其他属性有强依赖，或者为主属性，但存在一方不存在的情况

问题的根源在于模式的**数据依赖**设计

### 范式

依据关系模式的要求严苛程度，可以进一步分为多个范式，优化数据依赖的设计

将低范式通过**模式分解**可以转换为若干个高范式的集合，这种过程就叫**规范化**

以下逐一列出范式特点，高范式默认具有低范式的特点

- **第一范式**：

	所有属性都是不可分的基本数据项（关系模式基础要求）

	不符合的案例如一格中含有多个值

- **第二范式**：

	每一个非主属性完全函数依赖于候选码（但可以传递依赖于候选码）

- **第三范式**：

	每一个非主属性<u>不传递依赖</u>于候选码

	不符合的案例如（学号，部门，宿舍）

- **BC范式**：每一个函数依赖X→Y，若Y∉X，则X含有候选码（<u>若完全函数依赖，则为候选码</u>）

	不符合的案例如（学生，教师，课程），其中教师只教一门课程

- **第四范式**：不允许有非平凡且非函数依赖的多值依赖

	不符合的案例如（课程，教师，参考书籍），教师可以讲授多门课程，参考书可以供多门课程使用

需要注意的是，分解后的关系应当可以通过自然连接恢复为原来的关系，才能不丢失信息

同时，将函数依赖保留在同一数据库中，才能维持逻辑关系

